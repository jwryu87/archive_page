---
title:  "데이터베이스 아키텍처"
toc: true
toc_sticky: true
categories: SQL전문가가이드
---


### 1. 아키텍처 개관

#### 가. Oracel 아키텍처

![image](/assets/images/오라클 아키텍쳐.png)

#### 나. SQL server 아키텍처

![image](/assets/images/SQL 아키텍쳐.png)


----------


### 2. 프로세스

 - SQL server 는 쓰레드 기반의 아키텍처. 프로세스말고 쓰레드라는 말을 써라. 하지만 그냥 프로세스라고 통칭한다

#### 가. 서버 프로세스

 - 클라인언트가 서버 프로세스와 연결하는 방식은 DBMS마다 다르지만 Orcle 로 예로 들면, 전용 서버 방식과 공유 서버 방식, 두 가지다

##### 1) 전용 서버(Dedicated server) 방식

 - 만약 SQL을 수행할 떄마다 연결 요청을 반복하면 서버 프로세스의 생성과 해제도 반복하게 되므로 DBMS에 매우 큰 부담을 주고 성능을 크게 떨어뜨린다.
 - 따라서 전용 서버 방식을 사용하는 OLTP 성 애플리케이션에서 connection pooling 기법을 필수적으로 사용해야 한다.

#### 2) 공유서버(Shared Server) 방식

 - 하나의 서버 프로세스를 여러 사용자가 세션이 공유하는 방식


----------


### 3. 파일 구조

#### 가. 데이터 파일

 - 물리적으로 데이터 파일에 데이터를 저장하고 관리한다.

![image](/assets/images/데이터파일구조.png)

##### 1) 블록

 - 오라클은 2, 4, 8, 16, 32, 64KB 의 다양한 블록 크기
 - SQL 서버에서는 8KB 단일 크기를 사용
 - 블록 단위로 I/O 한다는 것은 하나의 레코드에서 하나의 칼럼만을 읽으려 할 때도 레코드가 속한 블록 전체를 읽게 됨을 뜻한다.
 - SQL 성능을 좌우하는 가장 중요한 성능지표는 액세스하는 블록의 개수

##### 2) 익스텐드

 - 데이터를 읽고 쓰는 단위는 블록이지만 테이블 스페이스로부터 공간을 할당하는 단위는 익스텐트다.
 - 블록은 논리적으로 인접하지만, 익스텐트끼지는 인접하지 않는다.
 - 오라클에서는 다양한 크기의 익스텐트 사용, SQL 서버에서는 8개 페이지의 익스텐트만 사용(8*8=64)
 - 오라클은 한 익스텐트에 속한 모든 블록을 단일 오브젝트가 사용하지만, SQL 서버에서는 2개 이상 오브젝트가 나누어 사용할 수도 있다.

##### 3) 세그먼트

 - 오라클 세그먼트, SQL 서버 힙 구조 또는 인덱스 구조의 오브젝트
 - 세그먼트는 테이블, 인덱스, Undo 처럼 저장공간을 필요로 하느 데이터베이스 오브젝트다.
 - 한 세트먼트는 자신이 속한 테이블 스페이스 내 여러 데이터 파일에 걸쳐 저장될 수 있다. 세그먼트에 할당된 익스텐트가 여러 데이터 파일에 흩어져 저장되는 것이며, 그래야 디스크 경합을 줄이고 I/O 분산 효과를 얻을 수 있다.

##### 4) 테이블 스페이스

 - 오라클: 테이블 스페이스, SQL 서버: 파일 그룹
 - 데이터 파일로 저장될 때 사용자가 데이터 파일을 직접 선택하지 않는다. 테이블 스페이스만 지정할 뿐
 - 각 세그먼트는 정확히 하나의 테이블 스페이스에 저장되지만, 한 테이블 스페이스는 여러 세그먼트가 존재할 수 있다.

#### 나. 임시 데이터 파일

 - 대량의 정렬이나 래시 작업을 수행하다가 메모리 공간이 부조갷지면 중간 결과집합을 저장하는 용도다.
 - Redo 정보를 생성하지 않는다. 때문에 나중에 문제 발생 시 복구되지 않는다.
 - 오라클: 임시 테이블 스페이스를 여러개 생성해 두고 사용자마다 별도의 임시 테이블 스페이스를 지정해 줄 수도있다.
 - SQL 서버: 단 하나의 tempdb 데이터 베이스를 사용한다.

#### 다. 로그 파일

 - DB 버퍼 캐시에 가해지는 모든 변경사항을 기록하는 파일을  오라클은 Redo 로그 라고 부르고 SQL 서버에서는 트랜잭션 로그 라고 부른다.
 - fast commit 매커니즘
 - 오라클: online redo 로그, 로그 스위칭, 라운드 로빈
 - SQL 서버: 트랜잭션 로그
 - Archived(=offline) redo 로그: 온라인 redo 로그가 재 사용되기 전에 다른 위치로 백업해 둔 파일을 말한다. 디스크가 깨지는 등 물리적인 저장매체에 문제가 생겼을 경우 데이터베이스 복구를 위해 사용된다. SQL 서버에 대응되는 개념이 없다.


----------


### 4. 메모리 구조

 - 시스템 공유 메모리 영역, 프로세스 전용 메모리 영역으로 구분
 - 시스템 공유 메모리 영역: 말그대로 여러 프로세스가 동시에 엑세스 할 수 있는 메모리 영역. 오라클: SGA, SQL서버: 메모리 풀
 - 모든 DBMS가 공통적으로 사용하는 캐시 영역으로는 DB 버퍼 캐시, 공유 풀, 로그 버퍼가 있다.
 - 프로세스 전용 메노리 영역: 오라클은 프로세스 기반 아키텍쳐이므로 서버 프로세스가 자신만의 전용 메모리 영역을 가질 수 있는데 이를 PGA: 데이터를 정렬하고 세션과 커서에 관한 상태 정보를 저장하는 용도
 - 쓰레드 기반 아키텍처를 사용하는 SQL 서버는 프로세스 전용 메모리 영역을 갖지 않는다.

#### 가. DB 버퍼 캐시

 - 데이터 파일로부터 읽어 들인 데이터 블록을 담는 캐시 영역
 - 인스턴스에 접속한 모든 사용자 프로세스는 서버 프로세스를 통해 DB 버퍼 캐시의 버퍼 블록을 동시에 액세스 할 수 있다.
 - 읽고자하는 블록을 먼저 버퍼 캐시에서 찾아보고 없을 때 디스크에서 읽는다.
 - 디스크에서 읽을 때도 먼저 버퍼 캐시에 적재한 후에 읽는다.
 - 데이터 변경도 버퍼 캐시에 적재된 블록을 통해 이루어지며, 변경된 블록을 주기적으로 데이터 파일에 기록하는 작업은 DBWR 프로세스의 몫이다.

##### 1) 버퍼 블록의 상태

 - Free 버퍼, Dirty 버퍼, Pinned 버퍼

##### 2) LRU 알고리즘

 - 사용빈도가 높은 데이터 블록 위주로 버퍼 캐시가 구성되도록 LRU(least recently used) 알고리즘을 사용한다.
 - 모든 버퍼 블록 헤더를 LRU 체인에 연결해 사용빈도 순으로 위치를 옮겨가다가, Free 버퍼가 필요해질 때면 액세스 빈도가 낮은 쪽 데이터 블록부터 밀어내는 방식이다.

#### 나. 공유 풀(Shared pool)

 - 딕셔너리 캐시, 라이브러리 캐시로 구성, SQL 서버에서는 프로시저 캐시가 같은 역할을 한다.

##### 1) 딕셔너리 캐시

 - 테이블, 인덱스 같은 오브젝트는 물론 테이블 스페이스, 데이터 파일, 세그먼트, 익스텐트, 사용자, 제약에 관한 메타 정보를 저장하는 곳이다.

>    - ex) 입력한 주문 데이터는 데이터 파일에 저장됐다가 버퍼 캐시를 경유해 읽히지만, 테이블 메타 정보는 딕셔너리에 저장됐다가 딕셔너리 캐시를 경유해 읽힌다.

##### 2) 라이브러리 캐시

 - 라이브러리 캐시는 사용자가 수행한 SQL문과 실행계획, 저장 프로시저를 저장해 두는 캐시영역이다.
 - SQL에 대한 반복적인 하드파싱을 최소화하기 위한 캐시 공간을 따로 두게 되었는데, 이것이 바로 라이브러리 캐시 영역이다.
 - 캐싱된 SQL과 그 실행계획의 재사용성을 높이는 것은 SQL 수행 성능을  높이고 DBMS 부하를 최소화하는 핵심 원리 중 하나이다.

#### 다. 로그 버퍼

 - 로그 엔트리도 파일에 곧바로 기록하는 것이 아니라 먼저 로그 버퍼에 기록한다.
 - 건건이 디스트에 기록하기 보다 일정량을 모았다가 기록하면 훨씬 빠르기 때문이다.
 - 서버 프로세스가 데이터 블록 버처에 변경을 가하기 전에 Redo 로그 버퍼에 먼저 기록해 두면 주기적으로 LGWG 프로세스가 Redo 로그 파일에 기록한다.
 - 오라클 Redo 로그, Redo 로그 버퍼, SQL 서버: 트랜젝션 로그, 로그 캐시
 - 로그 파일에 기록했음이 보장돼야 안심하고 커밋을 완료할 수 있다.

#### 라. PGA

 - 독립적인 메모리 공간
 - 오라클 서버 프로세스는 자신만의 PGA 메모리영역을 할당받고 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용한다.

##### 1) UGA

 - 전용서버 방식으로 연결할 때는 프로세스와 세션이 1 대1 관계를 갖지만
 - 공유서버 방식으로 연결할 때는 1 대 다 관계를 갖는다.
 - 공유에서 세션이 프로세스 개수보다 많아질 수 있는 구조로서 하나의 프로세스가 여러 개 세션을 위해 일한다.
 - 따라서 각 세션을 위한 독립적인 메모리 공간이 필요해지는데 이를 UGA라고 한다 .
 - 전용서버 방식 -> PGA, 공유서버 방식 -> SGA

##### 2) CGA

 - call 이 진행되는 동안에만 필요한 데이터는 CGA에 담는다.

##### 3) Sort Area

 - 쓰레드 기반 아키텍처를 사용하는 SQL 서버는 프로세스 전용 메모리 영역을 갖지 않는다.


----------


### 5. 대기 이벤트

 - 수많은 프로세스 간의 상호작용 과정에서 다른 프로세스가 일을 마칠때까지 기다려야만 하는 상황이 발생한다. 그때 sleep 상태에 들어가게 되는데 각 대기 유형별 상태와 시간 정보가 공유 메노리 영역에 저장된다.
 - 오라클: 대기 이벤트, SQL서버: 대기 유형
 - Response Time = Service Time(CPU Time) + Wait Time (Queue Time)
 - 대기 이벤트 종류가 만다 약 900여개
 - DB를 모니터링하거나 성능 진단 업무를 담당하지 않는다면 이 내용들을 굳이 공부하지 않아도 된다.

#### 가. 라이브러리 캐시 부하
#### 나. 데이터베이스 Call 과 네트워크 부하
#### 다. 디스크 I/O 부하
#### 라. 버퍼 캐시 경합
#### 마. Lock 관련 대기 이벤트