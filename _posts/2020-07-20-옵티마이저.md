---
title:  "옵티마이저"
toc: true
toc_sticky: true
---

----------

### 1. 옵티마이저 소개

#### 가. 옵티마이저란?

- 옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적(최저비용)의 처리경로를 생성해주는 DBMS 내부의 핵심엔진이다.
- 옵티마이저가 새성한 SQL 처리경로를 실행계획이라고 부른다.

![image](/assets/images/옵티마이저의 SQL 최적화 과정.jpg) 

- 사용자가 던진 쿼리수행을 위해 후보군이 될만한 실행계획을 찾는다.
- 데이터 딕셔너리에 미리 수집해 놓은 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다.
- 각 실행계획을 비교해서 최저비용을 갖는 하나르 선택한다.

#### 나. 옵티마이저 종류

1) 규칙기반 옵티마이저(RBO)

- 미리 정해 놓은 규칙에 따라 경로를 평가하고 실행계획을 선택한다.

2) 비용기반 옵티마이저(CBO)

- 비용을 기반으로 최적화를 수행한다.
- 비용이란 쿼리를 수행하는데 소요되는 일량 또는 시간을 뜻한다.
- 여기서 비용은 어디까지나 예상치다.
- 사용하는 통계항목으로는 레코드 개수, 블록 개수, 평균 행 길이, 칼럼 값의 수, 칼럼 값 분포, 인덱스 높이, 클러스터링 팩터 등 + 시스템 통계정보(CPU 속도, 디스트 I/O 속도)

#### 다. SQL 최적화 과정

- **Parser** : SQL 문장을 이루는 개별 구성요소를 분석하고 파싱해서 파싱 트리를 만든다. 이 과정에서 문법 체크(Syntax 체크), 의미 체크(Semantic 체크) 를 한다.
- **Optimizer** 
- **Query Transformer** : 파싱된 SQL을 좀 더 일반적이고 표준적인 형태로 변환한다.
- **Estimator** :  오브젝트 및 시스템 통계정보를 이용해 쿼리 수행 각 단계의 선택도, 카디널리티, 비용을 계산하고, 궁극적으로는 실행계획 전체에 대한 비용을 계산해 낸다.
- **Plan Generator** : 하나의 쿼리를 수행하는 데 있어, 후보군이 될만한 실행계획들을 생성해 낸다.
- **Row-Source Generator** : 옵티마이저가 생성한 실행계획을 SQL 엔진이 실제 실행할 수 있는 코드 형태로 포맷팅한다.
- **SQL Engine** : SQL을 실행한다.

#### 라. 최적화 목표 (560)

1) 전체 처리속도 최적화

- 쿼리 최종 결과집합을 끝까지 읽는 것을 전제로, 시스템 리소스를(I/O, CPU, 메모리 등)를 가장 적게 사용하는 실행계획을 선택한다


2) 최초 응답속도 최적화

- 전체 결과집합 중 일부만 읽다가 멈추는 것을 전제로, 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택한다.


----------


### 2. 옵티마이저 행동에 영향을 미치는 요소

#### 가. SQL과 연산자 형태

- SQL 형태, 어떤 연산자를 사용했는지에 따라 쿼리 성능에 영향을 미친다.

#### 나. 옵티마이징 팩터

- 쿼리를 똑같이 작성하더라도 인덱스, IOT, 클러스터링, 파티셔닝, MV 등을 어떻게 구성했는지에 따라 실행계획과 성능이 크게 달라진다.

#### 다. DBMS 제약 설정

- 예를 들어 not null 이 있으면 옵티마이저는 전체 개수를 구하는 count 쿼리에서 이 인덱스를 활용할 수 있다.

#### 라. 옵티마이저 힌트

- 사용자가 지정한 옵티마이저 힌트가 우선이다.

#### 마. 통계정보

- 통계정보가 옵티마이저에게 미치는 영향력은 절대적이다. 
- CBO의 모든 판단 기준은 통계정보에서 나온다.

#### 바. 옵티마이저 관련 파라미터

#### 사. DBMS 버전과 종류


----------


### 3. 옵티마이저의 한계

#### 가. 옵티마이징 팩터의 부족

- 옵티마이징 팩터(효과적으로 구성된 인덱스, IOT, 클러스터링, 파티셔닝) 을 제공하지 않는다면 좋은 실행계획을 수립할 수 없다.

#### 나. 통계정보의 부정확성

- 최적화에 필요한 모든 정보를 수집해서 보관할 수 있다면 옵티마이저도 그만큼 고성능 실행계획을 수립하겠지만 100% 정확한 통계정보를 유지하기는 현실적으로 불가능하다.
- 칼럼 분포가 고르지 않을 때 칼럼 히스토그램이 반드시 필요한데, 이를 수집하고 유지하는 비용이 만만치 않다.
- 칼럼을 결합했을 때의 모든 결합 분포를 미리 구해두기 어려운 것이 큰 제약 중 하나이다.

#### 다. 바인드 변수 사용 시 균등분포 가정

- 아무리 정확한 칼럼 히스토그램을 보유하더라도 바인드 변수를 사용한 SQL에는 무용지물이다. 
- 조건절에 바인드 변수를 사용하면 옵티마이저가 균등분포를 가정하고 비용을 계산하기 때문이다.

#### 라. 비현실적인 가정

- 옵티마이저는 쿼리 수행 비용을 평가할 때 여러 가정을 사용하는데, 그 중 일부는 상당히 비현실적이다. 
- DBMS 버전이 올라갈 수록 보완되고 있다.

#### 마. 규칙에 의존하는 CBO

- 아무리 비용기반 옵티마이저라 하더라도 부분적으로는 규칙에 의존한다. 

#### 바. 하드웨어 성능 특성


----------


### 4. 통계정보를 이용한 비용계산 원리

- 실행계획을 수립할 때 CBO는 SQL 문장에서 액세스할 데이터 특성을 고려하기 위해 통계정보를 이용한다.
- 그러므로 최적의 실행계획을 위해 통계정보가 항상 데이터 상태를 정확하게 반영하고 있어야 한다.
- DBMS 버전이 올라갈수록 자동 통계 관리 방식으로 바뀌고 있지만 가끔 수동으로 해줘야 한다.
- 테이블 통계 / 인덱스 통계 / 칼럼 통계 / 시스템 통계

#### 가. 선택도

- 전체 대상 레코드 중에서 특정 조건에 의해 서택될 것으로 예상되는 레코드 비율을 말한다.
- 선택도를 가지고 카디널리티를 구하고, 다시 비용을 구해 인덱스 사용 여부, 조인 순서와 방법들을 결정하므로 중요하다. ( = 선택도 -> 카디널리티 -> 비용 -> 액세스 방식, 조인 순서, 조인 방법 등 결정 )
- 히스토그램이 있으면 그것으로 선택도를 산정하는데 없으면 데이터 분포가 균일하다고 가정하여 선택도를 구한다.

> - 선택도 = 1 / distinct value 개수

#### 나. 카디널리티

- 특정 액세스 단계를 거치고 난 후 출력될 것으로 예상되는 결과 건수를 말한다.

> - 카디널리티 = 총 로우 수 * 선택도
> 
> ex) 부서가 10개면 선택도는 0.1, 총 사원 수가 1000명이면 카디널리티는 100 여기에 직급이 4개면 선택도는 0.25 이므로 0.25를 곱해준다.

#### 다. 히스토그램

- 미리 정해놓은 히스토그램 정보가 있으면 옵티마이저는 그것을 사용해 더 정확하게 카디널리티를 구할 수 있다.
- 도수분포 히스토그램
- 높이균형 히스토그램

#### 라. 비용

- 비용이란 쿼리를 수행하는데 소요되는 일량 또는 시간을 뜻하며, 예상치이다.
- 옵티마이저 비용 모델에는 I/O 비용 모델과 CPU 비용 모델 두 가지가 있다. 
- I/O 비용 모델 : 예상되는 I/O 요청 횟수만을 쿼리 수행 비용으로 간주해 실행계획을 평가함
- CPU 비용 모델 : 위에 시간 개념을 더해 비용을 산정한다. (여기서는 I/O 모델만 다룬다.)


----------


### 5. 옵티마이저 힌트

- 통계정보가 정확하지 않거나 기타 다른 이유로 옵티마이저가 잘못 판단할 수 있다.
- 그럴 때 프로그램이나 데이터 특성 정보를 알고 있는 개발자가 직접 인덱스를 지정하거나 조인방식을 변경함으로써 더 좋으 ㄴ실행 계획으로 유도할 수 있다.
- 힌트의 구체적인 사용법은 DBMS마다 천차만별이다.

#### 가. Oracle 힌트  
1) 힌트 기술 방법  
2) 힌트가 무시되는 경우  

> - 문법적으로 안 맞게 힌트를 기술
> - 의미적으로 안 맞게 힌트를 기술
> - 잘못된 참조 사용
> - 논리적으로 불가능한 액세스 경로
> - 버그
> - 옵티마이저는 힌트를 사용자로부터의 명령어로 인식한다.
> - 오라클은 사용자가 힌트를 잘못 기술해도 에러가 발생하지 않는다.

3) 힌트 종류    

![image](/assets/images/오라클힌트.png)

#### SQL server 힌트

 - 크게 3가지가 있다.   
 - SQL server 는 문법이나 의미적으로 맞지 않게 힌트를 기술하면 프로그램에서 에러가 난다.
 

> - 테이블힌트 : 테이블명 다음에 with 절을 통해 지정한다.   
> - 조인힌트 : from 절에 지전하여 두 테이블 간 조인 전략에 영향을 미친다.
> - 쿼리힌트 : 쿼리 맨 마지막에 한번만 지정할 수 있는 쿼리 힌트가 있다.

 


----------
